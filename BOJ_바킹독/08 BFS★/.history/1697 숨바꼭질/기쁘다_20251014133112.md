# 여담
![풀어냈다!](./기쁘당.PNG)

불문제처럼 큐에 넣고 차근차근 빼면서, 그 pop된 정보에서 1을 더해서 다시 넣는다는 원리를 사용했다. 

이때 메모리초과, 런타임에러, 시간초과 등 여튼 터질 수 있는건 다 터졌는데
이유는 바로바로~ 자료구조를 잘 몰랐기 때문...
배열이랑 덱을 이용한 큐를 쓰긴 했지만, 여전히 시간복잡도가 남아잇었다. **set**을 썼어야 했다. 

- 방문여부를 확인할 때
```
if (x-1) not in lst:
```
를 썼는데 이는 deque이기 때문에 in연산을 할 때 O(N)시간이 걸린다. 즉 탐색할 때마다 전체를 훑어봐야함. 

- 해결법은 set을 쓰는 것
set의 in연산은 O(1)이라서 훨씬 빠르다. 
```
visited = set()

visited.add(nx)
```
이런 식으로 써야함!! 

# `list`, `deque`, `queue`, `set`
이 네 가지(`list`, `deque`, `queue`, `set`)는 다 **데이터를 저장하고 꺼내는 방법**이 조금씩 다른 자료구조야.
하나씩 아주 간단하게 비교해볼게 👇

---

## `[list]` — 기본형, 하지만 느릴 수 있음
- append(요소)
- pop()

```python
lst = [1, 2, 3]
lst.append(4)   # 맨 뒤에 추가 (O(1))
lst.pop()       # 맨 뒤에서 제거 (O(1))
lst.pop(0)      # 맨 앞에서 제거 (O(N)) ← 느림!
```

* ✅ **장점:**

  * 인덱스로 접근 가능 (`lst[2]`)
  * 정렬, 슬라이싱 등 다양한 기능 지원
* ⚠️ **단점:**

  * 맨 앞에서 데이터를 빼거나 넣으면 **느림** (모든 원소가 한 칸씩 이동해야 함)
* 💡 **요약:**

  * “랜덤 접근이 필요한 경우(list는 인덱싱이 가능할 때)”에 좋음
  * **큐(BFS)** 용도로는 **비효율적**

---

## 2️⃣ `deque` — 빠른 큐, 빠른 스택

```python
from collections import deque

q = deque([1, 2, 3])
q.append(4)     # 오른쪽 추가 (O(1))
q.appendleft(0) # 왼쪽 추가 (O(1))
q.pop()         # 오른쪽 제거 (O(1))
q.popleft()     # 왼쪽 제거 (O(1))
```

* ✅ **장점:**

  * ➡️ **양쪽 끝에서 빠른 추가/삭제 (O(1))** ⬅️
  * _BFS, 큐(Queue), 스택(Stack) 구현에 최적_
* ⚠️ **단점:**

  * 인덱스로 접근할 때 느림 (`q[2]` 가능하지만 내부적으로 O(N))
* 💡 **요약:**

  * **순서대로 넣고 순서대로 꺼내는 BFS/Queue에 완벽한 구조**

---

## 3️⃣ `{set}` — “집합”, **순서 없고 중복 없음**
- add(요소)
- remove(요소)

```python
s = {1, 2, 3}
s.add(4)        # 추가
s.remove(2)     # 삭제
3 in s          # 포함 여부 확인 (O(1))
```

* ✅ **장점:**

  * **중복 자동 제거**
  * **포함 여부 확인이 빠름 (O(1))**
* ⚠️ **단점:**

  * 순서가 없음 (인덱스 접근 불가)
* 💡 **요약:**

  * “이걸 방문했었나?” “이 값이 이미 있나?” 같은 체크에 최적
  * BFS에서 **visited 집합**으로 많이 사용됨

---

## 📦 4️⃣ `queue.Queue` — 멀티스레드용 (일반적 BFS엔 안 씀)

```python
from queue import Queue

q = Queue()
q.put(1)      # 데이터 넣기
q.get()       # 데이터 꺼내기
```

* ✅ **장점:**

  * **스레드 안전(Thread-safe)** → 여러 스레드가 동시에 접근해도 안전
* ⚠️ **단점:**

  * 내부 락(lock) 때문에 **단일 스레드에서는 느림**
  * 인덱스로 접근 불가
* 💡 **요약:**

  * 보통 알고리즘 문제에서는 **deque**를 쓰고,
    멀티스레드 환경(예: 프로듀서-컨슈머 패턴)에선 `queue.Queue`를 씀.

---



## ⚙️ 한눈에 정리

| 자료구조          | 순서 유지 | 중복 허용 | 인덱싱 가능 | 추가/삭제 속도         | 주로 쓰는 용도     |
| ------------- | ----- | ----- | ------ | ---------------- | ------------ |
| `list`        | ✅     | ✅     | ✅      | 앞쪽 느림 (O(N))     | 일반 저장, 랜덤 접근 |
| `deque`       | ✅     | ✅     | ⚠️ 느림  | 앞뒤 모두 빠름 (O(1))  | 큐, BFS       |
| `queue.Queue` | ✅     | ✅     | ❌      | 느림 (Thread-safe) | 멀티스레드 큐      |
| `set`         | ❌     | ❌     | ❌      | 매우 빠름 (O(1))     | 방문체크, 중복 제거  |

---

## 🎯 BFS 예시로 비교

예를 들어 “숫자 n에서 k까지 이동하는 BFS”라면 이렇게 쓸 수 있어요 👇

| 역할       | 자료구조    | 이유               |
| -------- | ------- | ---------------- |
| 탐색 순서 저장 | `deque` | 앞에서 꺼내고 뒤에 넣기 빠름 |
| 방문 여부 기록 | `set`   | 이미 방문한 숫자 빠르게 확인 |

---
