# 0으로 된 리스트 만들기
참고: https://puleugo.tistory.com/41

### 리스트 생성하는 방법
- lst = [] 
- lst = list() #list함수 사용

- lst = [ 0 for _ in range(n) ] 
    위의 방법을 사용해서 2차원 리스트도 만들 수 있다. 
    ``` [[0 for i in range(m)] for _ in range(n)]```

# 틀린 코드
참고: https://www.acmicpc.net/board/view/149780

- 반례:
```
1
3 3 5
0 1
1 0
1 1
2 0
0 2
```
- 정답: 1

- 틀린 코드
```
from collections import deque

test_case = int(input())

def bae():
    m,n,k = map(int, input().split())

    #배추밭 만들기
    graph = [ [0 for _ in range(m)] for _ in range(n) ]

    print(graph)

    #배추좌표 받기
    q= deque()
    for _ in range(k):
        x,y = map( int, input().split() ) 
        graph[y][x] = 1
        q.append( (y,x) )

    # print(graph)

    #배추밭 개수 변수 정의
    count = 0

    dx = [0,0,1,-1]
    dy = [1,-1,0,0]

    #순회하기
    while q:
        x, y = q.popleft()
        #배추없으면 탈출
        print('pop!')
        for i in range(n):
            for j in range(m):
                if i==x and j==y:
                    print('★', end=' ')
                else:
                    print(graph[i][j], end=' ')
            print()

        ##배추가 잇습니다
        #새 배추가 있으면 개수 세어주고
        if graph[x][y]==1:
            print(f'count+1: ({x},{y})')
            count += 1

        #주변을 둘러보자
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if (0<=nx<n) and (0<=ny<m):
                if graph[nx][ny]==1: #아직 방문을 안했다. 
                    graph[nx][ny] = graph[x][y]+1 #방문처리
                    q.append( (nx, ny) ) #q에 넣어줌 (순회예정)
    print(graph)
    print(count)

for t in range(test_case):
    bae()
```

# 틀린 이유
참고: https://velog.io/@falling_star3/%EB%B0%B1%EC%A4%80Python-1012%EB%B2%88-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94

전형적인 BFS문제. 우리는 배추무리의 개수를 세어야 함. 


이때 나는 토마토문제처럼 큐에 모든 배추의 좌표를 다 넣었다가 의도처럼 제대로 bfs가 동작하지 않음. 이런 방식은 동시다발적으로 탐색해야 하는 경우에 적합하다. 배추밭처럼 개수세는 문제에서는 ```배추를 발견하고 - 그 배추 주변에 조건에 맞는 좌표들을 큐에 넣어주고 - 그 조.맞.좌들의 주변을 순회하는... 방식```으로 해줘야한다. 대신 바로 반복문으로 다 계산하는게 아니라 밖에서 배추를 발견하면 bfs를 실행시켜서 - 그 배추와 붙어있는 배추들은 다~ 순회한 다음에 - 다른 배추를 탐색하는 방식을 취해야 한다. 

## 비교분석
- me🚀: 배추의 위치를 입력받는 즉시 모든 배추의 좌표를 전부 큐에 넣어버린다. 그리고 bfs를 딱 한번만 실행. - 이 방식은 **연결된 군집을 구분할 수 없다.**
->  분리된 군집을 별개로 인식하고 개수를 세는 로직 자체가 없다. 모든 배추를 시작점으로 간주하고 탐색하기때문에 연결이 되어있든 아니든 결국 모든 배추를 방문함. 

- 정답👨‍🔬(**탐색과 발견**을 기반으로 한, 전형적인 '섬의 개수 세기' 알고리즘): 전체 배추밭을 순회하다가 아직 방문하지 않은 배추(1)를 발견하면 그때서야 비로소 그 지점에서부터 bfs를 시작하고 군집을 센다(count+1). 그리고 bfs를 통해 그와 연결된 모든 배추를 방문 처리(0으로 변경)하여 다시는 세지 않도록 만든다. 

    (1) 전체 순회 시작

    (2) 새로운 군집 발견

    (3) 카운트 및 bfs 실행
    - bfs를 실행하면 연결된 배추를 모두 방문처리하여, 다음번 순회에서 이 군집에 속한 배추들이 또 발견되어 중복으로 카운트 되는 것을 방지함. 

    (4) 다음 군집 탐색 (아직 방문하지 않은 새로운 군집에 속한 다음 배추를 찾아 나선다)

| 구분 | 첫 번째 방법 (동시 출동) | 두 번째 방법 (차근차근) |
|------|---------------------------|---------------------------|
| **비유** | 📢 "전원, 지금 즉시 모든 지점으로 출동!" | 🗺️ "구석부터 살피다 새로운 무리를 찾으면 출동!" |
| **시작 방식** | 모든 배추를 큐에 우르르 다 넣고 시작 | 밭을 하나씩 살피다 배추(1)를 만나면 시작 |
| **결과** | 벌레 무리가 몇 개인지 알 수 없음 | 벌레 무리가 몇 개인지 정확히 알 수 있음 |
| **정답 여부** | ❌ | ✅ |


## 각 방식의 활용방법 
- 첫번째 방식

    - 최단 시간 구하기: "창고에 있는 토마토들이 모두 익으려면 최소 며칠이 걸릴까?" (백준 '토마토' 문제)

        -> 처음부터 익어있는 모든 토마토(1)를 큐에 넣고 BFS를 돌려야, 모든 토마토가 동시에 익어가는 과정을 시뮬레이션할 수 있어요.

    - 동시 감염/확산: "바이러스가 여러 곳에서 동시에 퍼질 때, 모든 지역이 감염되는데 걸리는 시간은?"

    - 여러 출발지로부터의 최단 거리: "여러 개의 소방서 중, 우리 집에서 가장 가까운 소방서까지의 거리는?"

        -> 모든 소방서를 큐에 넣고 시작하면, BFS를 통해 가장 먼저 우리 집에 도착하는 경로를 찾을 수 있어요.

- 두 번째 방식
    - 영역 개수 세기: "지도에 섬이 총 몇 개 있나?" (백준 '섬의 개수' 문제)

        -> 땅(1)을 발견하면, BFS로 그 땅과 연결된 모든 땅을 찾아 바다(0)로 만들고, 섬 개수를 +1 해요.

    - 군집 개수 세기: "배추들이 몇 무더기로 모여 있나?" (지금 푸는 문제)

    - 연결 요소(Connected Component) 찾기: "소셜 네트워크에서 서로 친구 관계가 아닌 그룹이 총 몇 개 그룹인가?"

| 구분 | 패턴 1: 동시 출발 BFS | 패턴 2: 따로따로 정복 BFS |
|------|------------------------|----------------------------|
| **목표** | 모든 시작점에서 동시에 퍼질 때의 최소 시간/거리 | 서로 분리된 영역(덩어리)의 총 개수 |
| **큐(Queue) 초기화** | 모든 시작점을 처음에 다 넣어둠 | 빈 큐로 시작. 맵을 순회하다가 조건에 맞는 지점 하나를 발견하면 큐에 넣음 |
| **BFS 호출 횟수** | 딱 한 번 | 덩어리의 개수만큼 여러 번 |
| **대표 문제** | 토마토, 미로 최단거리 | 유기농 배추, 섬의 개수, 단지번호붙이기 |
