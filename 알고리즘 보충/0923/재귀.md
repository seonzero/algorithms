# 재귀함수에서 pop()의 기능
```
append()
함수(cnt+1)
pop
```

## 그림으로 이해하기
좋습니다 👍
그럼 `n=2`, `k=3` (숫자 1,2,3 중 두 자리 고르기)를 **재귀 호출 트리**로 그려서
`pop()` 있는 경우와 없는 경우를 비교해 드릴게요.



✅ **`pop()` 있는 경우 (정상 동작)**

트리에서 한 단계 내려갈 때마다 `append(i)`, 올라올 때 `pop()`으로 복구해요.

```
pick(0)       number = []
 ├── append(1) → [1]
 │    ├── append(1) → [1,1] → 검사 후 pop → [1]
 │    ├── append(2) → [1,2] → 검사 후 pop → [1]
 │    └── append(3) → [1,3] → 검사 후 pop → [1]
 │    pop → []
 │
 ├── append(2) → [2]
 │    ├── append(1) → [2,1] → 검사 후 pop → [2]
 │    ├── append(2) → [2,2] → 검사 후 pop → [2]
 │    └── append(3) → [2,3] → 검사 후 pop → [2]
 │    pop → []
 │
 └── append(3) → [3]
      ├── append(1) → [3,1] → 검사 후 pop → [3]
      ├── append(2) → [3,2] → 검사 후 pop → [3]
      └── append(3) → [3,3] → 검사 후 pop → [3]
      pop → []
```

👉 모든 경로에서 길이가 정확히 `n=2`인 경우만 검사됨.
👉 최종적으로 9가지 경우 `[1,1] … [3,3]` 전부 출력됨.

---

❌ `pop()` 없는 경우 (상태 복구 안 함)

트리에서 올라올 때 리스트를 복구하지 않으니 값이 계속 쌓여요.

```
pick(0)       number = []
 ├── append(1) → [1]
 │    ├── append(1) → [1,1] (검사됨)
 │    ├── append(2) → [1,1,2] ❌ 길이 초과
 │    └── append(3) → [1,1,2,3] ❌ 더 초과
 │    (복구가 안 되므로 [1,1,2,3]이 계속 남음)
 │
 ├── append(2) → [1,1,2,3,2] ❌ 쓰레기 누적
 └── append(3) → [1,1,2,3,2,3] ❌ 더 쓰레기 누적
```

👉 `number`가 지저분하게 길어져서 원하는 탐색이 안 되고,
👉 `IndexError` 같은 오류까지 발생.

---

🎯 핵심

* `append()`는 "새로운 선택"
* `pop()`은 "돌아오면서 선택 취소"
* **트리 탐색에서 상태를 원래대로 돌려야만 다음 가지(branch)를 정확히 탐색할 수 있다.**




## ✅ pop() 있는 경우
```
for i in range(1, 4):
    number.append(i) #1
    pick(cnt+1) # 11, 12, 13
    number.pop() #1
    # []
```
📌 과정:

첫 자리에서 1 → number = [1]

두 번째 자리에서 1 → number = [1,1] → 검사 후 pop() → number = [1]

두 번째 자리에서 2 → number = [1,2] → 검사 후 pop() → number = [1]

두 번째 자리에서 3 → number = [1,3] → 검사 후 pop() → number = [1]

➝ 다 끝나면 pop() → number = []

.

첫 자리에서 2 → number = [2]

두 번째 자리에서 1 → number = [2,1] → 검사 후 복구

두 번째 자리에서 2 → number = [2,2] → 검사 후 복구

두 번째 자리에서 3 → number = [2,3] → 검사 후 복구
➝ 다 끝나면 복구 → number = []

.

첫 자리에서 3도 같은 방식.

## ❌ pop() 없는 경우
```
for i in range(1, 4):
    number.append(i)
    pick(cnt+1)
    # pop() 없음
```

📌 과정:

첫 자리에서 1 → number = [1]

두 번째 자리에서 1 → number = [1,1] (검사 끝)

두 번째 자리에서 2 → number = [1,1,2] ❌ (이미 길이가 3인데 n=2여서 꼬임)

두 번째 자리에서 3 → number = [1,1,2,3] ❌

첫 자리에서 2 → number = [1,1,2,3,2] ❌ (쓰레기 값이 계속 쌓임)

👉 이렇게 되면 리스트가 점점 길어지고, is_beautiful()에서 인덱스 참조가 꼬이거나 조건 검사가 잘못돼요.

---

### 백트래킹(Backtracking)의 핵심

백트래킹은 시도했다가 실패하면 원래 상태로 돌려놓고 다른 시도를 하는 알고리즘이에요.

append()가 "시도"라면,

pop()은 "돌려놓기(복구)"죠.

이 복구 과정이 없으면, 리스트가 쌓이기만 해서 다른 경우의 수를 제대로 탐색할 수 없어요.